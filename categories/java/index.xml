<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 127.0.0.1</title>
    <link>http://127001.me/categories/java/</link>
    <description>Recent content in Java on 127.0.0.1</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 May 2016 00:59:08 +0200</lastBuildDate>
    <atom:link href="http://127001.me/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Overloading that is not permitted or Java bridge methods</title>
      <link>http://127001.me/post/java-bridge-methods/</link>
      <pubDate>Mon, 09 May 2016 00:59:08 +0200</pubDate>
      
      <guid>http://127001.me/post/java-bridge-methods/</guid>
      <description>

&lt;p&gt;Most of my technical interviews for Java developer position include a puzzle, where candidate should implement 2 very
similar interfaces in a single class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Implement both interfaces in a single class if possible. Explain why possible/not possible.

interface WithPrimitiveInt {
  void m(int i);
}

interface WithInteger {
  void m(Integer i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes candidates, not being sure about the right answer, are willing to solve the following puzzle instead (I give
it to candidates later anyway):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface S {
  String m(int i);
}

interface V {
  void m(int i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Indeed, the latter puzzle appears to be much easier, and most of the candidates answer, that implementation of both
methods in a signle class shouldn&amp;rsquo;t be possible, because the signatures of &lt;code&gt;S.m(int)&lt;/code&gt; and &lt;code&gt;V.m(int)&lt;/code&gt; are the same while
return types are different. And this is absolutely correct.&lt;/p&gt;

&lt;p&gt;Sometimes, though, I ask another question on the topic:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do you think, it would make any sense to allow implementation of methods with the same method signature but different
return types in a single class? Maybe, in some hypothetical JVM-based language or at least on a JVM level?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That&amp;rsquo;s kind of an open question and I do not expect a single correct answer here. But although I do not expect one, the
correct answer exists. And a person, who worked with the reflections API a lot, performed bytecode manipulations or read
JVM specification might know it.&lt;/p&gt;

&lt;h2 id=&#34;java-method-signature-vs-jvm-method-descriptor&#34;&gt;Java method signature vs JVM method descriptor&lt;/h2&gt;

&lt;p&gt;Java method signature (i.e. method name and types of parameters) is only imposed by Java compiler during compilation.
JVM, on the other hand, distinguishes methods in a class by a combination of the
&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.2.2&#34;&gt;unqualified method name&lt;/a&gt; (simply the name of
the method) and the
&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3&#34;&gt;method descriptor&lt;/a&gt;, that is a list of
parameter descriptors and one return descriptor.&lt;/p&gt;

&lt;p&gt;For example, if we wanted to invoke a method &lt;code&gt;String m(int i)&lt;/code&gt; directly on a class &lt;code&gt;foo.Bar&lt;/code&gt;, in the bytecode we&amp;rsquo;d need
to have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INVOKEVIRTUAL foo/Bar.m (I)Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and for &lt;code&gt;void m(int i)&lt;/code&gt; it would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INVOKEVIRTUAL foo/Bar.m (I)V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That said, JVM is perfectly fine with &lt;code&gt;String m(int i)&lt;/code&gt; and &lt;code&gt;void m(int i)&lt;/code&gt; in a single class. All we need to do, is to
generate proper bytecode.&lt;/p&gt;

&lt;h2 id=&#34;bytecode-kung-fu&#34;&gt;Bytecode Kung Fu&lt;/h2&gt;

&lt;p&gt;We have interfaces &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;, let&amp;rsquo;s generate now a class &lt;code&gt;SV&lt;/code&gt; which implements both those interfaces. Representation
in Java, if it was allowed, should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SV implements S, V {
  public void m(int i) {
    System.out.println(&amp;quot;void m(int i)&amp;quot;);
  }
  public String m(int i) {
    System.out.println(&amp;quot;String m(int i)&amp;quot;);
    return null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To generate bytecode we&amp;rsquo;ll use &lt;a href=&#34;http://asm.ow2.org/index.html&#34;&gt;Objectweb ASM library&lt;/a&gt;, which is low-level enough to get
a feeling of what JVM bytecode is.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/edio/java-bridge-methods&#34;&gt;Full source code&lt;/a&gt; is shared on github, here I&amp;rsquo;ll only list and explain
essential snippets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

// package edio.java.experiments
// public class SV implements S, V
cw.visit(V1_7, ACC_PUBLIC, &amp;quot;edio/java/experiments/SV&amp;quot;, null, &amp;quot;java/lang/Object&amp;quot;, new String[]{
    &amp;quot;edio/java/experiments/S&amp;quot;,
    &amp;quot;edio/java/experiments/V&amp;quot;
});

// constructor
MethodVisitor constructor = cw.visitMethod(ACC_PUBLIC, &amp;quot;&amp;lt;init&amp;gt;&amp;quot;, &amp;quot;()V&amp;quot;, null, null);
constructor.visitCode();
constructor.visitVarInsn(Opcodes.ALOAD, 0);
constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, &amp;quot;java/lang/Object&amp;quot;, &amp;quot;&amp;lt;init&amp;gt;&amp;quot;, &amp;quot;()V&amp;quot;);
constructor.visitInsn(Opcodes.RETURN);
constructor.visitMaxs(1, 1);
constructor.visitEnd();

// public String m(int i)
MethodVisitor mString = cw.visitMethod(ACC_PUBLIC, &amp;quot;m&amp;quot;, &amp;quot;(I)Ljava/lang/String;&amp;quot;, null, null);
mString.visitCode();
mString.visitFieldInsn(Opcodes.GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);
mString.visitLdcInsn(&amp;quot;String&amp;quot;);
mString.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;);
mString.visitInsn(Opcodes.ACONST_NULL);
mString.visitInsn(Opcodes.ARETURN);
mString.visitMaxs(2, 2);
mString.visitEnd();

// public void m(int i)
MethodVisitor mVoid = cw.visitMethod(ACC_PUBLIC, &amp;quot;m&amp;quot;, &amp;quot;(I)V&amp;quot;, null, null);
mVoid.visitFieldInsn(Opcodes.GETSTATIC, &amp;quot;java/lang/System&amp;quot;, &amp;quot;out&amp;quot;, &amp;quot;Ljava/io/PrintStream;&amp;quot;);
mVoid.visitLdcInsn(&amp;quot;void&amp;quot;);
mVoid.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &amp;quot;java/io/PrintStream&amp;quot;, &amp;quot;println&amp;quot;, &amp;quot;(Ljava/lang/String;)V&amp;quot;);
mVoid.visitInsn(Opcodes.RETURN);
mVoid.visitMaxs(2, 2);
mVoid.visitEnd();

cw.visitEnd();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start with creating &lt;code&gt;ClassWriter&lt;/code&gt; to generate bytecode.&lt;/p&gt;

&lt;p&gt;Then we declare a class, that implements interfaces &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Although, our reference pseudo-java code for &lt;code&gt;SV&lt;/code&gt; didn&amp;rsquo;t contain any constructors, we must generate code for it anyway,
if we do not declare constructors in Java, compiler implicitly generates empty constructor for us.&lt;/p&gt;

&lt;p&gt;In the methods bodies we start by obtaining the &lt;code&gt;out&lt;/code&gt; field of type &lt;code&gt;java.io.PrintStream&lt;/code&gt; from &lt;code&gt;System&lt;/code&gt; class and
pushing it onto the operand stack. Then we load a constant (&lt;code&gt;&amp;quot;String&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;void&amp;quot;&lt;/code&gt;) onto the stack and invoke &lt;code&gt;println&lt;/code&gt;
on an obtained &lt;code&gt;out&lt;/code&gt; reference with the string constant as an argument.&lt;/p&gt;

&lt;p&gt;Finally, for &lt;code&gt;String m(int i)&lt;/code&gt; we push a constant of type reference with value &lt;code&gt;null&lt;/code&gt; to stack and use a correspondingly
typed &lt;code&gt;return&lt;/code&gt; instruction, &lt;code&gt;ARETURN&lt;/code&gt; it is, to return a value back to a method caller. For the &lt;code&gt;void m(int i)&lt;/code&gt; we use
untyped &lt;code&gt;RETURN&lt;/code&gt; to only jump back to a method caller without returning a value.&lt;/p&gt;

&lt;p&gt;To verify, that our bytecode is correct (and I&amp;rsquo;ve been doing this all the time, iteratively fixing the issues), we write
the generated class to a filesystem&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Files.write(new File(&amp;quot;/tmp/SV.class&amp;quot;).toPath(), cw.toByteArray());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and use &lt;code&gt;jad&lt;/code&gt; (java decompiler) to turn bytecode back to java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jad -p /tmp/SV.class
The class file version is 51.0 (only 45.3, 46.0 and 47.0 are supported)
// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/kpdus/jad.html
// Decompiler options: packimports(3) 

package edio.java.experiments;

import java.io.PrintStream;

// Referenced classes of package edio.java.experiments:
//            S, V

public class SV
    implements S, V
{

    public SV()
    {
    }

    public String m(int i)
    {
        System.out.println(&amp;quot;String&amp;quot;);
        return null;
    }

    public void m(int i)
    {
        System.out.println(&amp;quot;void&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Close enough, I think.&lt;/p&gt;

&lt;h2 id=&#34;using-generated-class-in-runtime&#34;&gt;Using generated class in runtime&lt;/h2&gt;

&lt;p&gt;Successful decompilation by &lt;code&gt;jad&lt;/code&gt; actually guarantees us nothing. &lt;code&gt;jad&lt;/code&gt; warns us if there are major problems with the
bytecode, like frame size to local variables discrepancy or missing return statement. But in general we can&amp;rsquo;t be sure
that our generated class will do any job in runtime.&lt;/p&gt;

&lt;p&gt;To use generated class in runtime we need to load it somehow into JVM and then instantiate.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s implement our own &lt;code&gt;AsmClassLoader&lt;/code&gt;. It is just a convenient wrapper around &lt;code&gt;ClassLoader.defineClass&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AsmClassLoader extends ClassLoader {
  public Class defineAsmClass(String name, ClassWriter classWriter) {
    byte[] bytes = classWriter.toByteArray();
    return defineClass(name, bytes, 0, bytes.length);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s use that classloader and instantiate the class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassWriter cw = SVGenerator.generateClass();
AsmClassLoader classLoader = new AsmClassLoader();
Class&amp;lt;?&amp;gt; generatedClazz = classLoader.defineAsmClass(SVGenerator.SV_FQCN, cw);
Object o = generatedClazz.newInstance();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our class is generated in runtime, we can&amp;rsquo;t cast to it in our source code. We can cast to the implemented
interfaces though. And non-reflective invocation becomes possible with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((S)o).m(1);
((V)o).m(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the code, the output will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String
void
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To some the output might seem unexpected: we call &lt;em&gt;the same&lt;/em&gt; (from Java&amp;rsquo;s perspective) method on a class, but results
differ depending on the interface we cast object to. Mind-blowing, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;Things become clearer, if we think about the underlying bytecode. For the invocation we performed, compiler generates
&lt;code&gt;INVOKEINTERFACE&lt;/code&gt; instruction and the method descriptor comes not from the class, but from the interface.&lt;/p&gt;

&lt;p&gt;Thus, for the first invocation we&amp;rsquo;ll have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INVOKEINTERFACE edio/java/experiments/S.m (I)Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and for the second one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INVOKEINTERFACE edio/java/experiments/V.m (I)V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The object, on which invocation is performed, is obtained from the stack. And that is the power behind polymorphism in
Java.&lt;/p&gt;

&lt;h2 id=&#34;bridge-method-is-the-name&#34;&gt;Bridge method is the name&lt;/h2&gt;

&lt;p&gt;One might ask: “So what is the point of that all? Will you ever use that kind of stuff in your code?”&lt;/p&gt;

&lt;p&gt;The thing is that we do use this virtually every time we write usual Java code. For example, covariant return types,
generics and access to private fields from inner classes are implemented using similar “magic” in bytecode.&lt;/p&gt;

&lt;p&gt;Consider an interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ZeroProvider {
  Number getZero();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and its implementation returning a covariant type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class IntegerZero implements ZeroProvider {
  public Integer getZero() {
    return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s now think about the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IntegerZero iz = new IntegerZero();
iz.getZero();

ZeroProvider zp = iz;
zp.getZero();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the &lt;code&gt;iz.getZero()&lt;/code&gt; call compiler will generate &lt;code&gt;INVOKEVIRTUAL&lt;/code&gt; with &lt;code&gt;()Ljava/lang/Integer;&lt;/code&gt; method descriptor, while
for the &lt;code&gt;zp.getZero()&lt;/code&gt; it will generate &lt;code&gt;INVOKEINTERFACE&lt;/code&gt; with &lt;code&gt;()Ljava/lang/Number;&lt;/code&gt; method descriptor. We already
know, that JVM dispatches a call on the object by a method name and a method descriptor. Since descriptors are
different, those 2 calls can&amp;rsquo;t be dispatched to the same method in our &lt;code&gt;IntegerZero&lt;/code&gt; instance.&lt;/p&gt;

&lt;p&gt;In fact, compiler generates one additional method, which acts as a &lt;em&gt;bridge&lt;/em&gt; between the real method we declared in the
class, and the method used during invocation via interface. Hence the name — &lt;strong&gt;bridge method&lt;/strong&gt;. If only Java permitted
this, the resulting code would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class IntegerZero implements ZeroProvider {
  public Integer getZero() {
    return 0;
  }

  // This is a synthetic bridge method, which is present only in bytecode.
  // Java compiler wouldn&#39;t permit it.
  public Number getZero() {
    return this.getZero();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;afterword&#34;&gt;Afterword&lt;/h2&gt;

&lt;p&gt;Java programming language and Java Virtual Machine are not to be confused: although they share one common word in their
names and although Java is the main language for JVM, their possibilities and limitations are not always the same.
Knowing JVM helps a lot understanding Java or any other JVM-based language and knowing Java and its history, on the
other hand, helps understanding certain decisions in JVM design.&lt;/p&gt;

&lt;h2 id=&#34;related-links&#34;&gt;Related links&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se7/html/&#34;&gt;Java Virtual Machine Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://download.forge.objectweb.org/asm/asm4-guide.pdf&#34;&gt;ASM user guide [pdf]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/edio/java-bridge-methods&#34;&gt;Source code from the article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/921025/eclipse-warning-about-synthetic-accessor-for-private-static-nested-classes-in-jav&#34;&gt;Synthetic accessor for private nested classes in Java [StackOverflow]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>How Java logging frameworks determine caller class and method name</title>
      <link>http://127001.me/post/java-logging-caller-class-and-method/</link>
      <pubDate>Tue, 08 Apr 2014 23:54:49 +0200</pubDate>
      
      <guid>http://127001.me/post/java-logging-caller-class-and-method/</guid>
      <description>

&lt;p&gt;This post describes how java logging frameworks (Log4j, for example) know a point (concrete class and method name), where logging statement has been invoked.&lt;/p&gt;

&lt;p&gt;I decided to write this post, because quite often I communicate with developers, who do not understant what is the cost of writing caller information to logs, and why such high cost is imposed.&lt;/p&gt;

&lt;h1 id=&#34;brief-log4j-configuration-and-usage-overview&#34;&gt;Brief Log4J configuration and usage overview&lt;/h1&gt;

&lt;p&gt;Logger is identified by its name (a.k.a. category). Common myth here, is that logger is somehow connected with the class it is declared in. The myth is based on the signature of the factory method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final Logger log = LogManager.getLogger(MyService.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that&amp;rsquo;s just a shortcut for&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LogManager.getLogger(MyService.class.getName());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;category-vs-caller-class-name&#34;&gt;Category vs Caller class name&lt;/h2&gt;

&lt;p&gt;It is important to understand the difference between logger category (placeholder &lt;code&gt;%c&lt;/code&gt; in &lt;a href=&#34;http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html&#34;&gt;&lt;em&gt;PatternLayout&lt;/em&gt;&lt;/a&gt;) and caller class name (&lt;code&gt;%C&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Consider the following example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.my.company.name;
public class MyService {

  private static final Logger log1 = LogManager.getLogger(MyService.class);
  private static final Logger log2 = LogManager.getLogger(&amp;quot;blah-blah&amp;quot;);

  public void f() {
    log1.debug(&amp;quot;I&#39;m log1&amp;quot;);
    log2.debug(&amp;quot;I&#39;m log2&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When call to &lt;em&gt;f()&lt;/em&gt; is performed while logger is configured with pattern &lt;code&gt;%c - %m%n&lt;/code&gt;, log will contain&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.my.company.name.MyService - I&#39;m log1
blah-blah - I&#39;m log2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, if pattern is &lt;code&gt;%C - %m%n&lt;/code&gt;, we&amp;rsquo;ll get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.my.company.name.MyService - I&#39;m log1
com.my.company.name.MyService - I&#39;m log2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite of being named &lt;em&gt;blah-blah&lt;/em&gt;, the second logger somehow determined its caller class name.&lt;/p&gt;

&lt;h1 id=&#34;how-does-it-work&#34;&gt;How does it work?&lt;/h1&gt;

&lt;p&gt;Before JVM enters any method, it records the point from which this method is invoked to be able to return to that same point later, after the method returns. Let&amp;rsquo;s look at simple example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Example {
  public static void main(String[] args) { a(); }
  static void a() { getCallerInfo(); }
  static void getCallerInfo() { b(); }
  static void b() { throw new RuntimeException(); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method &lt;em&gt;b()&lt;/em&gt; throws an exception. Exception reaches the very top without being caught and its stacktrace gets printed to &lt;em&gt;System.err&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.RuntimeException
 at Example.b(Example.java:7)
 at Example.getCallerInfo(Example.java:6)
 at Example.a(Example.java:5)
 at Example.main(Example.java:4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having that stacktrace it is easy to say, that method &lt;em&gt;getCallerInfo()&lt;/em&gt; has been called from method &lt;em&gt;a()&lt;/em&gt;. So if we could get that stacktrace in runtime somehow and analyze it, we could find an invocation point for any method in our application.&lt;/p&gt;

&lt;h2 id=&#34;obtaining-stacktrace&#34;&gt;Obtaining stacktrace&lt;/h2&gt;

&lt;p&gt;There are few ways to get stacktrace in Java: &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#getStackTrace--&#34;&gt;&lt;em&gt;Thread.getStackTrace()&lt;/em&gt;&lt;/a&gt; and &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#getStackTrace--&#34;&gt;&lt;em&gt;Throwable.getStackTrace()&lt;/em&gt;&lt;/a&gt;. Both methods return array of &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/lang/StackTraceElement.html&#34;&gt;&lt;em&gt;StackTraceElement&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;throwable-getstacktrace&#34;&gt;Throwable.getStackTrace()&lt;/h4&gt;

&lt;p&gt;Usage is as simple as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Throwable().getStackTrace();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stacktrace gets filled in when &lt;em&gt;Throwable&lt;/em&gt; is created, so no need to throw it. Moreover, it is possible to reuse the same &lt;em&gt;Throwable&lt;/em&gt; instance calling &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#fillInStackTrace--&#34;&gt;&lt;em&gt;fillInStacktrace()&lt;/em&gt;&lt;/a&gt; to refresh stacktrace when needed (of course, keeping in mind possible race conditions if shared across threads).
Under the hood native method &lt;em&gt;Throwable.fillInStackTrace(int dummy)&lt;/em&gt; is invoked eventually.&lt;/p&gt;

&lt;h4 id=&#34;thread-getstacktrace&#34;&gt;Thread.getStackTrace()&lt;/h4&gt;

&lt;p&gt;Usage is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread.currentThread().getStackTrace();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although a bit cleaner, this method does not give other benefits and is a bit slower (it has to check, whether stack trace is obtained for current thread of for some other thread, doing necessary security checks if required). And in the end stacktrace is obtained from new &lt;em&gt;Exception&lt;/em&gt; instance in a way described above.&lt;/p&gt;

&lt;h2 id=&#34;parsing-stacktrace&#34;&gt;Parsing stacktrace&lt;/h2&gt;

&lt;p&gt;So we got array of &lt;em&gt;StackTraceElement&lt;/em&gt;. We need to iterate through that array and find such element whichs declaring class and method name properties satisfy some criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;quot;debug&amp;quot;.equals(methodName) &amp;amp; &amp;quot;my.company.Logger&amp;quot;.equals(declaringClass)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is very simple straightforward implementation of a logger, which knows everything about its caller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Logger {

  /**
   * Log message to stderr along with the caller class and method name.
   * @param msg message to log
   */
  public final void log(String msg) {
    StackTraceElement[] stackTrace = new Throwable().getStackTrace();
    // Index of StackTraceElement in stacktrace, where our logger appears.
    int i = getSelfElementIndex(stackTrace, this.getClass());
    // Caller is the next item down the stack.
    StackTraceElement caller = stackTrace[i + 1];
    System.err.println(caller.getClassName() + &amp;quot;.&amp;quot; + caller.getMethodName() + &amp;quot;: &amp;quot;
       + msg);
  }

  private int getSelfElementIndex(StackTraceElement[] stackTrace) {
    for (int i = 0; i &amp;lt; stackTrace.length; i++) {
      StackTraceElement el = stackTrace[i];
      // We don&#39;t need to check method name, our logger has only one method.
      if (el.getClassName().equals(this.getClass().getName())) {
        return i;
      }
    }
    throw new IllegalStateException(&amp;quot;Logger doesn&#39;t appear in stacktrace&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-about-log4j&#34;&gt;What about log4j&lt;/h1&gt;

&lt;p&gt;Of course, it&amp;rsquo;s a bit more complicated than that. Good points to start investigation are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;org.apache.log4j.spi.LocationInfo&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;org.apache.log4j.helpers.PatternParser.LocationPatternConverter&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>